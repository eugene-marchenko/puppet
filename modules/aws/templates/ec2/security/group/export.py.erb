#!/usr/bin/env python

import argparse
import boto
import logging
import re
import sys
import time
from difflib import unified_diff 

def get_creds():
    """
    Simple helper to get the credentials either from the environment or by
    manually setting them in the function
    """

    # By default empty, boto will look for environment variables
    # AWS_ACCESS_KEY_ID and AWS_SECRET_ACCESS_KEY
    ACCESSKEY='<%= accesskey %>'
    SECRETKEY='<%= secretkey %>'

    return ACCESSKEY, SECRETKEY

def get_args():
    """
    Simple helper to parse the command line argparse arguments
    """
    parser = argparse.ArgumentParser()
    parser.add_argument("-s", "--secgrp", dest="secgrp",
        help="the Security Group, e.g default")
    parser.add_argument("-f", "--file", dest="file",
        help="the file to persist security group information to")
    parser.add_argument("-d", "--diff", action='store_true', dest="diff",
        help="whether to diff the current security group output with a previous run")
    parser.add_argument("-r", "--region", dest="region", default="us-east-1",
        help="the region to use, e.g. us-east-1/us-west-2")
    parser.add_argument("-l", "--log", dest="loglevel", default='CRITICAL',
        choices=['CRITICAL','FATAL','ERROR','WARN','WARNING','INFO','DEBUG','NOTSET'],
        help="the loglevel sets the amount of output you want")
    return parser.parse_args()

def get_numeric_loglevel(loglevel):
    """Convert log level specified by string, e.g. 'DEBUG' to numeric"""
    return getattr(logging, loglevel.upper())

def get_conn(args):
    """Return EC2 connection object"""
    region = get_region(args)
    conn = boto.connect_ec2(args.accesskey, args.secretkey, region=region)
    return conn
 
def get_region(args):
    """Return RegionInfo object"""
    import boto.ec2
    regions = boto.ec2.regions(aws_access_key_id=args.accesskey,aws_secret_access_key=args.secretkey)
    for region in regions:
        if args.region == region.name:
            return region

def format_output(group,acls):
    """
    This creates a diff parseable text output of the various acls belonging to a
    group.
    """
    text = "GROUP %s %s %s %s\n" % (group.id, group.owner_id, group.name, group.description)
    acl_list = [text]
    for acl in acls:
        if acl.cidr_ip:
            txt = "    PERMISSION %s %s ALLOWS %s %s %s FROM CIDR %s %s\n" % (
                group.owner_id, group.name, acl.ip_protocol, acl.from_port,
                acl.to_port, acl.cidr_ip, acl.path)
            acl_list.append(txt)
        else:
            txt = "    PERMISSION %s %s ALLOWS %s %s %s FROM USER %s NAME %s ID %s %s\n" % (
                group.owner_id, group.name, acl.ip_protocol, acl.from_port,
                acl.to_port, acl.user, acl.name, acl.id, acl.path)
            acl_list.append(txt)

    return acl_list

class Acl(object):
    """Creates a acl object for easy parsing"""

    def __init__(self, rule, grant, path):
        self.rule = rule
        self.grant = grant
        self.path = path

    def parse(self):
        self.ip_protocol = self.rule.ip_protocol
        self.from_port = self.rule.from_port
        self.to_port = self.rule.to_port

        try:
            self.cidr_ip = self.grant.cidr_ip
        except AttributeError:
            self.cidr_ip = None
        try:
            self.user = self.grant.userId
        except AttributeError:
            self.user = None
        try:
            self.name = self.grant.groupName
        except AttributeError:
            self.name = None
        try:
            self.id = self.grant.groupId
        except AttributeError:
            self.id = None
   
def get_group_acls(group=None):
    """
    This will take a single group and create a list of acl objects. It
    basically flattens the hierachical acls that boto returns which nests
    grants in rules.
    """
    acls = []
    if group:
       for rule in group.rules:
           for grant in rule.grants:
               acl = Acl(rule,grant,'ingress')
               acl.parse()
               acls.append(acl)
       for rule in group.rules_egress:
           for grant in rule.grants:
               acl = Acl(rule,grant,'egress')
               acl.parse()
               acls.append(acl)

    return acls

def run():
    """
    Main function. Provides for the ability to extract security groups from aws,
    format them into a diff parseable txt file, write to a file or stdout, and
    output unified diffs to stdout
    """
    (accesskey, secretkey) = get_creds()
    args = get_args()
    args.accesskey = accesskey
    args.secretkey = secretkey
    numeric_level = get_numeric_loglevel(args.loglevel)
    logging.basicConfig(format='%(asctime)s:%(levelname)s:%(message)s', level=numeric_level) 
    conn = get_conn(args)
    # Run over every security group or just the ones provided
    if args.secgrp:
        groups = conn.get_all_security_groups(groupnames=args.secgrp.split(','))
    else:
        groups = conn.get_all_security_groups()

    out = []
    for group in sorted(groups, key=lambda group: group.name):
        out.append(format_output(group, get_group_acls(group)))

    # Flatten the list
    out = [ item for sublist in out for item in sublist ]

    # Will only run diff if a file argument was passed, diff needs something
    # to diff against.
    if args.diff and args.file:
        diff_left = open(args.file, 'r').readlines()
        diff_right = out
        for line in unified_diff(diff_left,diff_right,
                fromfile='AWS Security Groups', tofile='AWS Security Groups'):
            sys.stdout.write(line)
    elif args.file:
        with open(args.file, 'w') as f:
            f.write(''.join(out))
    else:
        print ''.join(out),

if __name__ == '__main__':
    run()
